geneRank[[1]]
test_file
test_file("tests/testthat/test-genePertScore.R")
test_file("tests/testthat/test-genePertScore.R")
load_all()
document()
test_package("sSNAPPY")
test_package("sSNAPPY")
test_package("sSNAPPY")
y <- matrix(c(c(1:5, 2:6, 3:7), c(1:5, 2:6, 3:7)+ 0.2), 5, 6)
rownames(y) <- c("7105","8813","57147","55732","2268" )
colnames(y) <- c("patient1_control", "patient1_treat1", "patient1_treat2",
"patient2_control", "patient2_treat1", "patient2_treat2")
sample <- colnames(y) %>%
as.data.frame()
colnames(sample) <- c("sample")
sample <- sample %>%
dplyr::mutate(
treatment = vapply(.$sample, function(x){
stringr::str_split(x, "_")[[1]][2]
}, character(1)),
treatment = factor(treatment, levels = c("control", "treat1", "treat2")),
patient = vapply(.$sample, function(x){
stringr::str_split(x, "_")[[1]][1]
}, character(1)))
ssFC <- weight_ss_fc(y, sample, groupBy  = "patient", sampleColumn = "sample", treatColumn = "treatment")
pathwayDir <- system.file("extdata", "gsTopology.rda", package = "sSNAPPY")
load(pathwayDir)
# the number of pathways with at least one of those five genes in it
intersectName <- names(gsTopology[lapply(gsTopology, function(x){length(intersect(rownames(ssFC$weighted_logFC),rownames(x)))}) != 0])
y_withNA <- y
y_withNA[2,2] <- NA
# create logCPM matrix with gene_id as rownames (instead of entrezID required)
y_wrongIdentifier <- y
rownames(y_wrongIdentifier) <- c("ENSG00000000003","ENSG00000000419","ENSG00000000457","ENSG00000000460","ENSG00000000938")
ssFC_wrongIdentifier <- weight_ss_fc(y_wrongIdentifier, sample, groupBy  = "patient", sampleColumn = "sample", treatColumn = "treatment")
test_that("generate_permuted_scores returns error when expected", {
expect_error(generate_permuted_scores(y_wrongIdentifier, gsTopology = gsTopology,
weight = ssFC_wrongIdentifier$weight), "None of the expressed gene was matched to pathways. Check if gene identifiers match")
expect_error(generate_permuted_scores(y, gsTopology = gsTopology,
weight =ssFC$weight[1:10]), "Gene-wise weights do not match with the dimension of expreMatrix")
expect_error(generate_permuted_scores(y_withNA, gsTopology = gsTopology,
weight = ssFC$weight), "NA values not allowed")
# create a testScore data.frame containing wrong gs_name
testScore <- data.frame(
gs_name = 1:5
)
expect_error(generate_permuted_scores(y, gsTopology = gsTopology,
weight = ssFC$weight,
testScore = testScore),
"None of the pathways had non-zero test perturbation scores")
})
test_that(".generate_permutedFC produces the expected outcome", {
# if NB is provided, the number of column in the returned output should
# equal to the specified NB
temp <- .generate_permutedFC(y, NB = 2, weight = ssFC$weight)
expect_equal(dim(temp), c(nrow(y), 2))
})
test_that("generate_permuted_scores produces the expected outcome", {
genePertScore <- raw_gene_pert(ssFC$weighted_logFC, gsTopology)
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
temp <- generate_permuted_scores(y, NB = 2, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp), length(unique(ssPertScore$gs_name)))
expect_equal(length(temp[[1]]), 2)
# when NB isn't specified, the number of permuted scores generated for
# each pathway should equal sample size x (sample size -1)
temp <- generate_permuted_scores(y, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp[[1]]), ncol(y)*(ncol(y) -1))
# When the column number isn't an even number, the maximum permutation pairs
# should still be sample size x (sample size -1)
temp <- generate_permuted_scores(y[,-1], weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp[[1]]), (ncol(y) -1)*(ncol(y) -2))
# If the required NB is bigger than the maxmimum number of permutations
# possible, exhuast permutation choice
temp <- generate_permuted_scores(y,  NB = 200,
weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp[[1]]), ncol(y)*(ncol(y) -1))
})
test_that("Test data.frame input for generate_permuted_scores", {
temp <- generate_permuted_scores(as.data.frame(y),
weight = ssFC$weight,
gsTopology = gsTopology[intersectName])
expect_equal(length(temp), length(intersectName))
expect_equal(length(temp[[1]]), ncol(y)*(ncol(y) -1))
})
test_that("Test DGEList input for generate_permuted_scores", {
dge <- edgeR::DGEList(counts = y)
temp <- generate_permuted_scores(dge,  NB = 2, weight = ssFC$weight,
gsTopology = gsTopology[intersectName])
expect_equal(length(temp), length(intersectName))
})
test_that("Test SummarizedExperiment input for generate_permuted_scores", {
dge <- SummarizedExperiment::SummarizedExperiment(assays=list(counts=y))
temp <- generate_permuted_scores(dge, NB = 2, weight = ssFC$weight,
gsTopology = gsTopology[intersectName])
expect_equal(length(temp), length(intersectName))
})
notExpressed <- setdiff(unique(unlist(unname(lapply(gsTopology, rownames)))), rownames(y))
if (length(notExpressed) != 0){
temp <- matrix(0, nrow = length(notExpressed), ncol = ncol(y))
rownames(temp) <- notExpressed
colnames(temp) <- colnames(y)
y <- rbind(y, temp)
ssFC$weight <- c(ssFC$weight, rep(0, length(notExpressed)))
}
permutedFC <- .generate_permutedFC(y, NB = 2, weight = ssFC$weight)
test_that("normalise_by_permu produces the expected outcome",{
perS <- list(
"kegg.Chemokine signaling pathway"= rnorm(40, mean = 1, sd = 0.3)
)
genePertScore <- raw_gene_pert(ssFC$weighted_logFC, gsTopology)
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
output <- normalise_by_permu(perS, ssPertScore)
expect_equal(levels(output$sample),
c("patient1_treat1", "patient1_treat2", "patient2_treat1", "patient2_treat2"))
expect_false(anyNA(output$robustZ))
expect_false(any(output$MAD == 0))
expect_true(is.factor(output$gs_name))
output_sorted <- normalise_by_permu(perS, ssPertScore, sortBy = "pvalue")
expect_equal(which.min(pull(output_sorted, pvalue)), 1)
})
perS <- list(
"kegg.Chemokine signaling pathway"= rnorm(40, mean = 1, sd = 0.3)
)
genePertScore <- raw_gene_pert(ssFC$weighted_logFC, gsTopology)
genePertScore
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
output <- normalise_by_permu(perS, ssPertScore)
ssPertScore
load_all()
output <- normalise_by_permu(perS, ssPertScore)
pAdj_method <- match.arg(pAdj_method, p.adjust.methods)
sortBy <- match.arg(sortBy)
pvalue_ls <- lapply(unique(testScore$gs_name), function(x){
temp <- dplyr::filter(testScore, gs_name == x)
mutate(
temp,
pvalue = vapply(temp$score, function(y){
(sum(
abs(permutedScore[[x]]) >= abs(y)
) ) / (length(permutedScore[[x]]) )
}, numeric(1))
)
})
unique(testScore$gs_name)
temp <- dplyr::filter(testScore, gs_name == x)
x <- "kegg.N-Glycan biosynthesis"
mutate(
temp,
pvalue = vapply(temp$score, function(y){
(sum(
abs(permutedScore[[x]]) >= abs(y)
) ) / (length(permutedScore[[x]]) )
}, numeric(1))
)
temp
temp <- dplyr::filter(testScore, gs_name == x)
testScore
dplyr::filter(testScore, gs_name == x)
temp <- dplyr::filter(testScore, gs_name == x)
TEMP
temp
vapply(temp$score, function(y){
(sum(
abs(permutedScore[[x]]) >= abs(y)
) ) / (length(permutedScore[[x]]) )
}, numeric(1))
vapply(temp$score, function(y){
(sum(
abs(permutedScore[[x]]) >= abs(y)
) ) / (length(permutedScore[[x]]) )
}, numeric(1))
permutedScore[[x]]
permutedScore
load_all()
temp <- generate_permuted_scores(dge, NB = 2, weight = ssFC$weight,
gsTopology = gsTopology[intersectName])
dge <- SummarizedExperiment::SummarizedExperiment(assays=list(counts=y))
temp <- generate_permuted_scores(dge, NB = 2, weight = ssFC$weight,
gsTopology = gsTopology[intersectName])
x <- gsTopology[[1]]
x
gs_sub <- x[rownames(x) %in% allGene, colnames(x) %in% allGene ]
ident(rownames(allGene), allGene)
identical(rownames(allGene), allGene)
identical(rownames(gs_sub), allGene)
head
head(rownames(gs_sub))
head(allGene)
y <- 1
de <- permutedFC[rownames(permutedFC) %in% rownames(gs_sub), y]
de <- de[match(rownames(gs_sub), names(de))]
identical(names(de), rownames(gs_sub))
head(de)
head(rownames(gs_sub))
all(rownames(x) %in% allGene)
permute_Gene <- lapply(gsTopology, function(x){
#gs_sub <- x[rownames(x) %in% allGene, colnames(x) %in% allGene ]
if (abs(det(x))>1e-7){
netP_ls <- lapply(seq_len(ncol(permutedFC)), function(y){
# subset the FC vector to only pathway genes
de <- permutedFC[rownames(permutedFC) %in% rownames(x), y]
# make sure the rownames of the topology matrix matches with
# the nanmes of the FC vector
de <- de[match(rownames(x), names(de))]
solve(t(x), -de) - de
})
do.call(cbind,netP_ls)
} else {
NULL
}
})
permute_Gene
load_all()
test_package("sSNAPPY")
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
output <- normalise_by_permu(perS, ssPertScore)
load_all()
output <- normalise_by_permu(perS, ssPertScore)
pvalue_ls <- lapply(unique(tested_gs), function(x){
temp <- dplyr::filter(testScore, gs_name == x)
mutate(
temp,
pvalue = vapply(temp$score, function(y){
(sum(
abs(permutedScore[[x]]) >= abs(y)
) ) / (length(permutedScore[[x]]) )
}, numeric(1))
)
})
pvalue_ls <- lapply(unique(names(testScore)), function(x){
temp <- dplyr::filter(testScore, gs_name == x)
mutate(
temp,
pvalue = vapply(temp$score, function(y){
(sum(
abs(permutedScore[[x]]) >= abs(y)
) ) / (length(permutedScore[[x]]) )
}, numeric(1))
)
})
pvalue_ls
pvalues <- bind_rows(pvalue_ls)
summary_func <- function(x){c(MAD = mad(x), MEDIAN = median(x))}
summaryScore <- t(sapply(permutedScore, summary_func))
gs_name <- rownames(summaryScore)
summaryScore <- mutate(as.data.frame(summaryScore), gs_name = gs_name)
summaryScore <- dplyr::filter(summaryScore, summaryScore$MAD != 0)
summaryScore <- left_join(summaryScore, testScore, by = "gs_name",
multiple = "all")
summaryScore <- mutate(
summaryScore, robustZ =
(summaryScore$score - summaryScore$MEDIAN)/summaryScore$MAD)
# summaryScore <- mutate(
#     summaryScore, z_pvalue = 2*pnorm(-abs(summaryScore$robustZ)))
summaryScore <- left_join(summaryScore, pvalues,
by = c("gs_name", "score", "sample"))
summaryScore <- split(summaryScore, f = summaryScore$sample)
summaryScore <- lapply(summaryScore, mutate,
adjPvalue = p.adjust(pvalue, pAdj_method),
# adjPvalue_z = p.adjust(z_pvalue, pAdj_method)
)
summaryScore <-bind_rows(summaryScore)
summaryScore <- dplyr::mutate_at(
summaryScore, vars(c("gs_name", "sample")), as.factor
)
summaryScore[
order(pull(summaryScore, sym(sortBy)), decreasing = FALSE),]
pvalue_ls
names(permutedScore)
# Check if null distribution was simulated for all tested gene-sets
if (!all(names(permutedScore) %in% testScore)){
warning("Permutation scores not available for some tested gene-sets.
Those gene-sets will be removed.")
testScore <- dplyr::filter(testScore, gs_name %in% names(permutedScore))
}
load_all()
output <- normalise_by_permu(perS, ssPertScore)
unique(names(testScore))
unique(testScore$gs_name)
pvalue_ls <- lapply(unique(testScore$gs_name), function(x){
temp <- dplyr::filter(testScore, gs_name == x)
mutate(
temp,
pvalue = vapply(temp$score, function(y){
(sum(
abs(permutedScore[[x]]) >= abs(y)
) ) / (length(permutedScore[[x]]) )
}, numeric(1))
)
})
pvalue_ls
load_all()
ssPertScore
perS <- list(
"kegg.Chemokine signaling pathway"= rnorm(40, mean = 1, sd = 0.3)
)
genePertScore <- raw_gene_pert(ssFC$weighted_logFC, gsTopology)
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
output <- normalise_by_permu(perS, ssPertScore)
output
expect_equal(levels(output$sample),
c("patient1_treat1", "patient1_treat2", "patient2_treat1", "patient2_treat2"))
expect_equal(unique(output$gs_name), "kegg.Chemokine signaling pathway")
expect_false(anyNA(output$robustZ))
expect_equal(unique(output$gs_name), "kegg.Chemokine signaling pathway")
unique(output$gs_name)
expect_equal(levels(output$gs_name), "kegg.Chemokine signaling pathway")
expect_false(anyNA(output$robustZ))
expect_false(any(output$MAD == 0))
expect_true(is.factor(output$gs_name))
output_sorted <- normalise_by_permu(perS, ssPertScore, sortBy = "pvalue")
expect_equal(which.min(pull(output, pvalue)), 1)
output
test_package("sSNAPPY")
?sSNAPPY::plot_gene_contribution
document()
load_all()
test_package("sSNAPPY")
library(covr)
report()
data(metadata_example)
data(logCPM_example)
ls <- weight_ss_fc(logCPM_example, metadata = metadata_example,
sampleColumn = "sample", groupBy = "patient", treatColumn = "treatment")
ls$weighted_logFC
ls <- weight_ss_fc(logCPM_example, metadata = metadata_example,
sampleColumn = "sample", groupBy = "patient", treatColumn = "treatment", predix = "random")
load_all()
ls <- weight_ss_fc(logCPM_example, metadata = metadata_example,
sampleColumn = "sample", groupBy = "patient", treatColumn = "treatment", predix = "random")
ls <- weight_ss_fc(logCPM_example, metadata = metadata_example,
sampleColumn = "sample", groupBy = "patient", treatColumn = "treatment", prefix = "random")
ls$weighted_logFC
load_all()
document()
document()
document()
load_all()
getLoadedDLLs()
library(devtools)
load_all()
getLoadedDLLs()
document(".")
document(".")
load_all()
library(devtools)
load_all()
test_package("sSNAPPY")
load_all()
remove.packages("sSNAPPY")
load_all()
# when NB isn't specified, the number of permuted scores generated for
# each pathway should equal sample size x (sample size -1)
temp <- generate_permuted_scores(y, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
load_all()
y <- matrix(c(c(1:5, 2:6, 3:7), c(1:5, 2:6, 3:7)+ 0.2), 5, 6)
rownames(y) <- c("7105","8813","57147","55732","2268" )
colnames(y) <- c("patient1_control", "patient1_treat1", "patient1_treat2",
"patient2_control", "patient2_treat1", "patient2_treat2")
sample <- colnames(y) %>%
as.data.frame()
colnames(sample) <- c("sample")
sample <- sample %>%
dplyr::mutate(
treatment = vapply(.$sample, function(x){
stringr::str_split(x, "_")[[1]][2]
}, character(1)),
treatment = factor(treatment, levels = c("control", "treat1", "treat2")),
patient = vapply(.$sample, function(x){
stringr::str_split(x, "_")[[1]][1]
}, character(1)))
ssFC <- weight_ss_fc(y, sample, groupBy  = "patient", sampleColumn = "sample", treatColumn = "treatment")
pathwayDir <- system.file("extdata", "gsTopology.rda", package = "sSNAPPY")
load(pathwayDir)
# the number of pathways with at least one of those five genes in it
intersectName <- names(gsTopology[lapply(gsTopology, function(x){length(intersect(rownames(ssFC$weighted_logFC),rownames(x)))}) != 0])
y_withNA <- y
y_withNA[2,2] <- NA
# create logCPM matrix with gene_id as rownames (instead of entrezID required)
y_wrongIdentifier <- y
rownames(y_wrongIdentifier) <- c("ENSG00000000003","ENSG00000000419","ENSG00000000457","ENSG00000000460","ENSG00000000938")
ssFC_wrongIdentifier <- weight_ss_fc(y_wrongIdentifier, sample, groupBy  = "patient", sampleColumn = "sample", treatColumn = "treatment")
test_that("generate_permuted_scores returns error when expected", {
expect_error(generate_permuted_scores(y_wrongIdentifier, gsTopology = gsTopology,
weight = ssFC_wrongIdentifier$weight), "None of the expressed gene was matched to pathways. Check if gene identifiers match")
expect_error(generate_permuted_scores(y, gsTopology = gsTopology,
weight =ssFC$weight[1:10]), "Gene-wise weights do not match with the dimension of expreMatrix")
expect_error(generate_permuted_scores(y_withNA, gsTopology = gsTopology,
weight = ssFC$weight), "NA values not allowed")
# create a testScore data.frame containing wrong gs_name
testScore <- data.frame(
gs_name = 1:5
)
expect_error(generate_permuted_scores(y, gsTopology = gsTopology,
weight = ssFC$weight,
testScore = testScore),
"None of the pathways had non-zero test perturbation scores")
})
test_that(".generate_permutedFC produces the expected outcome", {
# if NB is provided, the number of column in the returned output should
# equal to the specified NB
temp <- .generate_permutedFC(y, NB = 2, weight = ssFC$weight)
expect_equal(dim(temp), c(nrow(y), 2))
})
test_that("generate_permuted_scores produces the expected outcome", {
genePertScore <- raw_gene_pert(ssFC$weighted_logFC, gsTopology)
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
temp <- generate_permuted_scores(y, NB = 2, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp), length(unique(ssPertScore$gs_name)))
expect_equal(length(temp[[1]]), 2)
# when NB isn't specified, the number of permuted scores generated for
# each pathway should equal sample size x (sample size -1)
temp <- generate_permuted_scores(y, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp[[1]]), ncol(y)*(ncol(y) -1))
# When the column number isn't an even number, the maximum permutation pairs
# should still be sample size x (sample size -1)
temp <- generate_permuted_scores(y[,-1], weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp[[1]]), (ncol(y) -1)*(ncol(y) -2))
# If the required NB is bigger than the maxmimum number of permutations
# possible, exhuast permutation choice
temp <- generate_permuted_scores(y,  NB = 200,
weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
expect_equal(length(temp[[1]]), ncol(y)*(ncol(y) -1))
})
temp <- generate_permuted_scores(y, NB = 2, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
genePertScore <- raw_gene_pert(ssFC$weighted_logFC, gsTopology)
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
temp <- generate_permuted_scores(y, NB = 2, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
# when NB isn't specified, the number of permuted scores generated for
# each pathway should equal sample size x (sample size -1)
temp <- generate_permuted_scores(y, weight = ssFC$weight,
gsTopology = gsTopology,
testScore = ssPertScore)
NB <- NULL
NB > 2
document()
load_all()
test_package("sSNAPPY")
load_all()
expect_warning(output <- normalise_by_permu(perS, ssPertScore))
output <- normalise_by_permu(perS, ssPertScore)
perS <- list(
"kegg.Chemokine signaling pathway"= rnorm(40, mean = 1, sd = 0.3)
)
y <- matrix(c(c(1:5, 2:6, 3:7), c(1:5, 2:6, 3:7)+ 0.2), 5, 6)
genePertScore <- raw_gene_pert(ssFC$weighted_logFC, gsTopology)
ssPertScore <- pathway_pert( genePertScore, ssFC$weighted_logFC)
output <- normalise_by_permu(perS, ssPertScore)
unique(testScore$gs_name)
!all(names(permutedScore) %in% tested_gs)
all(names(permutedScore) %in% tested_gs)
tested_gs %in% names(permutedScore
)
all(tested_gs %in% names(permutedScore))
!all(tested_gs %in% names(permutedScore))
# Check if null distribution was simulated for all tested gene-sets
if (!all(tested_gs %in% names(permutedScore))){
warning("Permutation scores not available for some tested gene-sets.
Those gene-sets will be removed.")
#if not, gene-sets without permuted scores will be removed
testScore <- dplyr::filter(testScore, gs_name %in% names(permutedScore))
}
unique(testScore$gs_name)
#if not, gene-sets without permuted scores will be removed
testScore <- dplyr::filter(testScore, gs_name %in% names(permutedScore))
unique(testScore$gs_name)
pvalue_ls <- lapply(unique(testScore$gs_name), function(x){
temp <- dplyr::filter(testScore, gs_name == x)
mutate(
temp,
pvalue = vapply(temp$score, function(y){
# count # of permuted values as or more extreme than test score
sum(
# use >= so the smallest possible pvalue is 1/NB
abs(permutedScore[[x]]) >= abs(y)
)  /
# divide by the total number of permuted values
length(permutedScore[[x]])
}, numeric(1))
)
})
load_all()
test_package("sSNAPPY")
roxygen2::roxygenise()
load_all()
roxygen2::roxygenise()
?orxygenise
?roxygen2::roxygenise
roxygen2::roxygenise(clean = TRUE)
