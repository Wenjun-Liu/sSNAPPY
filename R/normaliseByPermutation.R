#' @title Permute sample labels to simulate null distribution of perturbation scores
#'
#' @description Simulate null distributions of perturbation scores for each pathway through sample permutation.
#'
#' @details
#' This function firstly randomly permute sample labels NB times to generate permuted logFCs, which are then used to compute permuted perturbation
#' scores for each pathway. The function outputs a list that is of the same length as the list storing pathway topology matrices. Each
#' element of the output list is for a pathway and contains a vector of permuted perturbation score of length NB. It's assumed that the
#' permuted perturbation scores can be used to estimate the null distributions of perturbation scores.
#'
#' The input logCPM matrix should be identical to the input used for `weight_ssFC` function. If the requested number of permutation (NB) is larger than the maximum number of permutations possible, NB will be set to the largest
#' number of permutations possible instead.
#'
#' @param logCPM Matrix of normaslised logCPM where rows are genes and columns are samples. Row names need to be gene entrez IDs.
#' @param numOfTreat Number of treatments (including control)
#' @param NB Number of permutations
#' @param gsTopology List of pathway topology matrices generated using function `retrieve_topology`
#' @param weight A vector of gene-wise weights derived from function `weight_ssFC`
#' @param BPPARAM The parallel back-end to uses, if not specified, it is defaulted to the one returned by \code{BiocParallel::bpparam()}.
#' @import Rcpp
#' @importFrom BiocParallel bpparam bplapply
#' @return A list where each element is a vector of perturbation scores for a pathway.
#' @export
#'
#' @examples
#' #compute weighted single sample logFCs
#' data(metadata_example)
#' data(logCPM_example)
#' ls <- weight_ssFC(logCPM_example, metadata = metadata_example,
#'  factor = "patient", control = "Vehicle")
#'
#' # explore all species and databases supported by graphite
#' \dontrun{
#' load(system.file("extdata", "gsTopology.rda", package = "sSNAPPY"))
#' permutedScore <- generate_PermutedScore(logCPM_example, numOfTreat = 3,
#'  NB = 1000, gsTopology = gsTopology, weight = ls$weight)
#'
#' # To see what other parallel back-end can be used:
#'  BiocParallel::registered()
#'  }

generate_PermutedScore <- function(logCPM, numOfTreat,
                                        NB = 1000,
                                        gsTopology, weight, BPPARAM = BiocParallel:: bpparam()){

    # checks
    m <- min(logCPM)
    if (is.na(m)) stop("NA values not allowed")

    if ( ncol(logCPM) %% numOfTreat != 0 )
        stop ("Number of samples must be divisible by the number of treatments")
    if (nrow(logCPM) != length(weight))
        stop("Gene-wise weights do not match with the dimension of logCPM")
    logCPM <- as.matrix(logCPM)

    rownames(logCPM) <- paste("ENTREZID:", rownames(logCPM), sep = "")
    if (length(intersect(rownames(logCPM), unlist(unname(lapply(gsTopology, rownames))))) == 0)
        stop("None of the expressed gene was matched to pathways. Check if gene identifiers match")

    # test if the required number of permutations is bigger than the maximum number of permutations possible
    NB <- min(NB, factorial(ncol(logCPM)))

    # set expression values and weights of unexpressed pathway genes to 0
    notExpressed <- setdiff(
        unique(unlist(unname(lapply(gsTopology, rownames)))),
        rownames(logCPM))
    if (length(notExpressed) != 0){
        temp <- matrix(0, nrow = length(notExpressed), ncol = ncol(logCPM))
        rownames(temp) <- notExpressed
        colnames(temp) <- colnames(logCPM)
        logCPM <- rbind(logCPM, temp)
        weight <- c(weight, rep(0, length(notExpressed)))

    }

    permutedFC <- .generate_permutedFC(logCPM, numOfTreat, NB, weight)

    allG <- rownames(logCPM)
    newS <-  ncol(permutedFC[[1]])

    BiocParallel::bplapply(gsTopology, function(x){
        temp <- permutedPertScore_RCPP(X = x, pathwayG = rownames(x), allG,
    permutedFC = permutedFC, newS)
        unlist(temp)
    }, BPPARAM = BPPARAM)


}

#' @title Normalise test perturbation scores by permutation
#'
#' @details Normalise the test perturbation scores generated by `weight_ssFC` through the permuted perturbation scores derived from
#' the `generate_PermutedScore` function. The mean absolute deviation(MAD) and median of perturbation scores for each pathway are firstly
#' derived from the permuted perturbation scores. The test perturbation scores are then converted to robust z-scores using MADs and medians
#' calculated.
#' @param permutedScore A list. Output of `generate_PermutedScore`
#' @param testScore A matrix. Output of `weight_ssFC`
#' @param pAdj_method Method for adjusting p-values for multiple comparisons. See `?p.adjust` for methods available. Default to FDR.
#'
#' @importFrom stats mad median p.adjust pnorm
#' @importFrom dplyr left_join mutate
#' @return A dataframe.
#' @export
#'
#' @examples
#' \dontrun{
#' load(system.file("extdata", "gsTopology.rda", package = "sSNAPPY"))
#' ssPertScore <- compute_perturbationScore(ls$logFC, gsTopology)
#' permutedScore <- generate_PermutedScore(logCPM_example, numOfTreat = 2,
#'  NB = 1000, gsTopology = gsTopology, weight = ls$weight)
#' normalisedScores <- normalise_byPermu(permutedScore, ssPertScore)
#'  }
#'  # Load the example output
#'  load(system.file("extdata", "normalisedScores.rda", package = "sSNAPPY"))
#'  normalisedScores
normalise_byPermu <- function(permutedScore, testScore, pAdj_method = "fdr"){
    pvalue <- NULL
    summary_func <- function(x){c(MAD = mad(x), MEDIAN = median(x))}
    summaryScore <- as.data.frame(t(vapply(permutedScore, summary_func, c("MAD" = 0, "MEDIAN" = 0))))
    summaryScore <- rownames_to_column(summaryScore,"gs_name")
    summaryScore <- filter(summaryScore, summaryScore$MAD != 0)
    summaryScore <- left_join(summaryScore, testScore, by = "gs_name")
    summaryScore <- mutate(summaryScore,robustZ = (summaryScore$tA - summaryScore$MEDIAN)/summaryScore$MAD)
    summaryScore <- mutate(summaryScore, pvalue = 2*pnorm(-abs(summaryScore$robustZ)))
    summaryScore <- split(summaryScore, f = summaryScore$sample)
    summaryScore <-lapply(summaryScore, mutate, adjPvalue = p.adjust(pvalue, pAdj_method))
    bind_rows(summaryScore)

}


.generate_permutedFC <- function(logCPM, numOfTreat,
                                 NB, weight){
    nSample <- ncol(logCPM)
    index <- seq(1, nSample, by = numOfTreat)
    lapply(seq_len(NB), function(x){
        # permute sample labels to get permuted logCPM
        logCPM <- logCPM[,sample(seq_len(nSample), nSample)]
        temp <- lapply(seq_along(index), function(y){
      (logCPM[,seq(index[[y]]+1, index[[y]]+numOfTreat-1)] - logCPM[,index[[y]]]) * weight
        })
        do.call(cbind, temp)
    })



}



