#' @title Simulate permuted perturbation scores
#'
#' @description Simulate null distributions of perturbation scores for each pathway through sample permutation.
#'
#' @details
#' This function firstly randomly permute sample labels NB times to generate permuted logFCs, which are then used to compute permuted perturbation
#' scores for each pathway. The function outputs a list that is of the same length as the list storing pathway topology matrices. Each
#' element of the output list is for a pathway and contains a vector of permuted perturbation score of length NB. It's assumed that the
#' permuted perturbation scores can be used to estimate the null distributions of perturbation scores.
#'
#' The input logCPM matrix should be identical to the input used for `weight_ssFC` function. If the requested number of permutation (NB) is larger than the maximum number of permutations possible, NB will be set to the largest
#' number of permutations possible instead.
#'
#' @param logCPM Matrix of normaslised logCPM where rows are genes and columns are samples. Row names need to be gene entrez IDs.
#' @param numOfTreat Number of treatments (including control)
#' @param NB Number of permutations
#' @param filePath The file path to pathway topology matrices generated using function `weightedAdjMatrix`
#' @param weight A vector of gene-wise weights derived from function `weight_ssFC`
#'
#' @return A list where each element is a vector of perturbation scores for a pathway.
#' @export
#'
#' @examples
#' require(AnnotationHub)
#' require(ensembldb)
#' # convert rownamews of logCPM from gene ids to gene entrez IDs through `AnnotationHub`
#' ah <- AnnotationHub()
#' ah <- subset(ah,genome == "GRCh38" & title == "Ensembl 101 EnsDb for Homo sapiens")
#' ensDb <- ah[[1]]
#' rownames(logCPM_example) <- mapIds(ensDb, rownames(logCPM_example), "ENTREZID", keytype = "GENEID")
#'
#' # Remove genes that couldn't be matched to entrez IDs
#' logCPM_example <- logCPM_example[!is.na(rownames(logCPM_example)),]
#'
#' #compute weighted single sample logFCs
#' ls <- weight_ssFC(logCPM_example, metadata = metadata_example,
#'  factor = "patient", control = "Vehicle")
#'
#' # explore all species and databases supported by graphite
#' graphite::pathwayDatabases()
#' weightedAdjMatrix(species = "hsapiens",
#' database = "kegg",
#' outputDir = "BminsI.rda")
#'
#' permutedScore <- generate_PermutedScore(logCPM_example, numOfTreat = 2,
#'  NB = 100, filePath = "BminsI.rda", weight = ls$weight)
generate_PermutedScore <- function(logCPM, numOfTreat,
                                        NB = 1000,
                                        filePath, weight){
    BminsI <- NULL

    # checks
    if (!file.exists(filePath)) stop("Pathway topology matrices not detected")
    m <- min(logCPM)
    if (is.na(m)) stop("NA values not allowed")

    # load pathway topologies
    load(filePath)
    logCPM <- as.matrix(logCPM)
    rownames(logCPM) <- paste("ENTREZID:", rownames(logCPM), sep = "")
    if (length(intersect(rownames(logCPM), unlist(unname(lapply(BminsI, rownames))))) == 0)
        stop("None of the expressed gene was matched to pathways. Check if gene identifiers match")

    # test if the required number of permutations is bigger than the maximum number of permutations possible
    NB <- min(NB, factorial(ncol(logCPM)))

    # set expression values and weights of unexpressed pathway genes to 0
    notExpressed <- setdiff(unique(unlist(unname(lapply(BminsI, rownames)))), rownames(logCPM))
    if (length(notExpressed) != 0){
        temp <- matrix(0, nrow = length(notExpressed), ncol = ncol(logCPM))
        rownames(temp) <- notExpressed
        colnames(temp) <- colnames(logCPM)
        logCPM <- rbind(logCPM, temp)
        weight <- c(weight, rep(0, length(notExpressed)))

    }

    permutedPertScore_RCPP(BminsI = BminsI, expressedG = rownames(logCPM), LogCPM = logCPM,
                           NB = NB, sEachp = numOfTreat, weight = weight)
    # permutedScore <- permutedScore[!sapply(permutedScore, is.null)]


}

#' @title Normalise test perturbation scores by permutation
#'
#' @details Normalise the test perturbation scores generated by `weight_ssFC` through the permuted perturbation scores derived from
#' the `generate_PermutedScore` function. The mean absolute deviation(MAD) and median of perturbation scores for each pathway are firstly
#' derived from the permuted perturbation scores. The test perturbation scores are then converted to robust z-scores using MADs and medians
#' calculated.
#' @param permutedScore A list. Output of `generate_PermutedScore`
#' @param testScore A matrix. Output of `weight_ssFC`
#' @param pAdj_method Method for adjusting p-values for multiple comparisons. See `?p.adjust` for methods available. Default to FDR.
#'
#' @importFrom stats mad median p.adjust pnorm
#' @importFrom dplyr left_join mutate
#' @return A dataframe.
#' @export
#'
#' @examples
#' require(AnnotationHub)
#' require(ensembldb)
#' # convert rownamews of logCPM from gene ids to gene entrez IDs through `AnnotationHub`
#' ah <- AnnotationHub()
#' ah <- subset(ah,genome == "GRCh38" & title == "Ensembl 101 EnsDb for Homo sapiens")
#' ensDb <- ah[[1]]
#' rownames(logCPM_example) <- mapIds(ensDb, rownames(logCPM_example), "ENTREZID", keytype = "GENEID")
#'
#' # Remove genes that couldn't be matched to entrez IDs
#' logCPM_example <- logCPM_example[!is.na(rownames(logCPM_example)),]
#'
#' #compute weighted single sample logFCs
#' ls <- weight_ssFC(logCPM_example, metadata = metadata_example,
#'  factor = "patient", control = "Vehicle")
#'
#' # explore all species and databases supported by graphite
#' graphite::pathwayDatabases()
#' weightedAdjMatrix(species = "hsapiens",
#' database = "kegg",
#' outputDir = "BminsI.rda")
#'
#' # compute test perturbation scores
#' ssPertScore <- perturbationScore(ls$logFC, "BminsI.rda")
#' # generate permuted perturbation scores
#' permutedScore <- generate_PermutedScore(logCPM_example, numOfTreat = 2,
#'  NB = 100, filePath = "BminsI.rda", weight = ls$weight)
#' normalisedScores <- normaliseByPermutation(permutedScore, ssPertScore)
normaliseByPermutation <- function(permutedScore, testScore, pAdj_method = "fdr"){

    summary_func <- function(x){c(MAD = mad(x), MEDIAN = median(x))}
    summaryScore <- as.data.frame(t(sapply(permutedScore, summary_func)))
    summaryScore <- rownames_to_column(summaryScore,"gs_name")
    summaryScore <- filter(summaryScore, summaryScore$MAD != 0)
    summaryScore <- left_join(summaryScore, testScore, by = "gs_name")
    summaryScore <- mutate(summaryScore,
           robustZ = (summaryScore$tA - summaryScore$MEDIAN)/summaryScore$MAD)
    summaryScore <- mutate(summaryScore,
           pvalue = 2*pnorm(-abs(summaryScore$robustZ)))
    summaryScore <- split(summaryScore, f = summaryScore$sample)
    summaryScore <-lapply(summaryScore, mutate, adjPvalue = p.adjust(summaryScore$pvalue, "fdr"))
    bind_rows(summaryScore)

}



#' #' Title
#' #'
#' #' @param logCPM
#' #' @param metadata
#' #' @param factor
#' #' @param control
#' #' @param seed
#' #' @param NB
#' #' @param scores
#' #' @param filPath
#' #' @param weight
#' #'
#' #' @importFrom tibble rownames_to_column
#' #' @importFrom dplyr left_join filter mutate select
#' #' @return
#' #' @export
#' #'
#' #' @examples
#' normaliseByPermutation_R <- function(logCPM, metadata, factor, control,
#'                                    seed = sample.int(1e+06, 1), NB = 1000,
#'                                    scores, filePath, weight){
#'     logCPM <- as.matrix(logCPM)
#'     metadata <- as.data.frame(metadata)
#'
#'     # checks
#'     if (!all(c("treatment", "sample", factor) %in% colnames(metadata))) stop("Sample metadata must include factor, treatment and sample")
#'     if (any(c(!control %in% unique(metadata$treatment), length(unique(metadata[,"treatment"])) <2))) stop(
#'         "Treatment needs at least 2 levels where one is the control specified")
#'     if (ncol(logCPM) != nrow(metadata)) stop("Sample metadaata does not match with logCPM's dimension")
#'     m <- min(logCPM)
#'     if (is.na(m)) stop("NA values not allowed")
#'
#'
#'     # load pathway topologies
#'     BminsI <- readRDS(filePath)
#'     rownames(logCPM) <- paste("ENTREZID:", rownames(logCPM), sep = "")
#'     if (length(intersect(rownames(logCPM), unlist(unname(lapply(BminsI, rownames))))) == 0)
#'         stop("None of the expressed gene was matched to pathways. Check if gene identifiers match")
#'
#'     # if gene-wise weights are not provided, estimate again
#'     if (is.null(weight)) stop("Gene-wise weight must be provided. See details.")
#'
#'     notExpressed <- setdiff(unique(unlist(unname(lapply(BminsI, rownames)))), rownames(logCPM))
#'     if (length(notExpressed) != 0){
#'         temp <- matrix(0, nrow = length(notExpressed), ncol = ncol(logCPM))
#'         rownames(temp) <- notExpressed
#'         colnames(temp) <- colnames(logCPM)
#'         logCPM <- rbind( logCPM, temp)
#'         weight <- c(weight, rep(0, length(notExpressed)))
#'     }
#'
#'     # this step will probably benefit from BiocParallel but my laptop freezes with 2 workers
#'     permutedFC <- .generate_permutedFC(logCPM, metadata, factor, control, weight, NB, seed)
#'
#'     # Remove pathways with 0 expressed genes in it
#'     # kg2keep <- sapply(names(BminsI), function(x){
#'     #     length(intersect(rownames(permutedFC[[1]]),
#'     #                      rownames(BminsI[[x]]))) > 0
#'     # })
#'     # BminsI <- BminsI[kg2keep]
#'
#'     # compute permuted perturbation scores and remove pathways returned to be NULL
#'
#'     permutedScore <- lapply(permutedFC, ssPertScore_RCPP, BminsI = BminsI)
#'     permutedScore <- do.call(mapply, c(FUN=c, lapply(permutedScore, `[`, names(BminsI))))
#'     permutedScore <- permutedScore[!sapply(permutedScore, is.null)]
#'
#'     summary_func <- function(x){c(MAD = mad(x), MEDIAN = median(x))}
#'     summaryScore <- as.data.frame(t(sapply(permutedScore, summary_func)))
#'     summaryScore <- rownames_to_column(summaryScore,"gs_name")
#'     summaryScore <- filter(summaryScore, MAD != 0)
#'     summaryScore <- left_join(summaryScore, scores, by = "gs_name")
#'     mutate(summaryScore, robustZ = (tA - MEDIAN)/MAD )
#'
#' }


#' #' Title
#' #'
#' #' @param logCPM
#' #' @param metadata
#' #' @param factor
#' #' @param control
#' #' @param BPPARAM
#' #' @param seed
#' #'
#' #' @return
#' #'
#' #' @examples
#' .generate_permutedFC <- function(logCPM, metadata, factor, control, weight, NB, seed){
#'     metadata <- as.data.frame(metadata)
#'     pairs <- unique(metadata[,factor])
#'     sampleInpairs <- sapply(pairs, function(x){
#'         contrSample <- dplyr::filter(metadata, treatment == control, !!sym(factor) == x)
#'         contrSample <- pull(contrSample, sample)
#'
#'         treatedSample <- dplyr::filter(metadata, treatment != control, !!sym(factor) == x)
#'         treatedSample <- pull(treatedSample, sample)
#'         list(contrSample = contrSample, treatedSample = treatedSample)
#'     }, simplify = FALSE)
#'
#'     nSample <- nrow(metadata)
#'     NB <- min(factorial(nSample), NB)
#'     set.seed(seed)
#'
#'
#'     sapply(1:NB, function(x){
#'         # permute sample labels to get permuted logCPM
#'         colnames(logCPM) <- sample(colnames(logCPM), ncol(logCPM))
#'
#'         # Built permuted logFCs based on the permuted logCPM
#'         permutedFC <- sapply(names(sampleInpairs), function(y){
#'             logCPM[, sampleInpairs[[y]]$treatedSample] - logCPM[, sampleInpairs[[y]]$contrSample]
#'         }, simplify = FALSE)
#'         permutedFC <- do.call(cbind,permutedFC)
#'
#'         # Multiply permuted FCs by gene-wise weights
#'         permutedFC * weight
#'
#'     }, simplify = FALSE)
#'
#' }




